import React, { useState, useEffect } from 'react'
import lunr from 'lunr'
//import Doc1 from '../../docs/create-a-blog-post.md'
import ReactDOMServer from 'react-dom/server'
import md2json from 'md-2-json'
import html2md from 'html-to-md'
import useDocusaurusContext from '@docusaurus/useDocusaurusContext';
const path = require('path');
import useGlobalData from '@docusaurus/useGlobalData';
import fs from 'fs'
import ReactMd from 'react-md-file';
import route from '../../.docusaurus/routes'
import client from '../../.docusaurus/client-manifest.json'
import lurnr, {idx as testtt} from './Lurn.js'

function SearchBar() {
const [mdPaths, setMdPath] = useState([]);

useEffect(() => {
	let origins = Object.keys(client.origins);
let sites = [];	
  origins.forEach(site => {
    let format = site.slice(-4);
    let rawPath = site.slice(6);	  
    if (format.includes('.md') || format.includes('.mdx')) {
      sites.push(rawPath);
    }
  })	
 setMdPath(sites);
 let raws = [];
 let head = '#';	
 let rawHead = '';	
 sites.map(path => {
 let pathArr = path.split('/');	 
 let folder = path.split('/')[0];	
 let pathEnd = path.split('/')[pathArr.length - 1];	 
 pathEnd = pathEnd.match(/([a-z]+\-\w+)/i) ? pathEnd.match(/([a-z]+\-\w+)/i) : pathEnd; 
 let isBlog = folder === 'blog' ? true : false; 	 

 let fullPath = '../../'+ path;
  	 
  fetch(fullPath).then(res => res.text())
    .then(md => {
	    con
      let from = 0;
      let hashAt;	   
      for(let i=0; i < md.length; i++) {
        if (md[i] === '\n'&& md[i+1] !== '\n') {
 let raw = {"head":'', "text": ''};	

       if (i > hashAt && hashAt === from) {
	  let strHash = md.slice(from, i);
//		 console.log(strHash)
	  strHash = strHash.split('{')[0];
 	  strHash = strHash.toLowerCase();		
  	 let strToPath = strHash.replace(/[#]\s/g, '#');
	  strToPath = strToPath.trim();	
//		console.log(strToPath);
	  strToPath = strToPath.replace(/(')|([?])|([!])|([$])|([&])|([(])|([)])|([*])|([+])|([,])|([;])|([=])/g, '');		
	  strToPath = strToPath.replace(/(:)|(\s)|(@)/g, '-');		
          strToPath = strToPath.replace(/[-]+/g, '-');		
//		console.log(strToPath);
 let hashT = strHash.match(/#+/);	  		
	  rawHead = hashT[0]
          raw.head = isBlog ? routePaths(path) + strToPath : path + strToPath;	
//		 console.log(hashT);
//            if (head.length < hashT.length) {
	      head = hashT;
//	    }
	    
	}
	
	let rawText = md.slice(from, i);
rawText = rawText.replace(/(\[)|(\])|([(].+[)])|(<(“[^”]*”|'[^’]*’|[^'”>])*>)|(\n)|([{]\s?#+.+[}])/g, '');
		raw.text = rawText;
//		console.log(raw);
//	        raws.push(raw);
        from = i + 1;		
	}
          if (md[i] === '#' && md[i-1] === '\n') {
 	  hashAt = i;		  
//		 console.log('#')
	   }    
      }
//	    console.log(raws.length)
//console.log(raws);	    
    })
 })
	 console.log('effect: ', raws);
}, []);
	
function routePaths(target) {
  let paths = [];	
  route.forEach(obj => {
  let path = obj.path;	 
  let pathArr = path.split('/');	  
  if (path.indexOf(target)) {
	  return path;
  }
/*
  if(pathArr.length > 2 && pathArr[2] !== 'tags' && path.slice(0,5) === '/blog') {
  paths.push(path); 
  console.log(pathArr);
  }
	  */
  })
  return paths;	
}

async function handleSearch(e) { 
 const idx = lunr(function() {
this.ref('head');
this.field('text');
this.metadataWhitelist = ['position'];
//console.log('hook: ',mdPaths)
 let raws = [];
 let head = '#';	
 let rawHead = '';	
 mdPaths.map(path => {
 let pathArr = path.split('/');	 
 let folder = path.split('/')[0];	
 let pathEnd = path.split('/')[pathArr.length - 1];	 
 pathEnd = pathEnd.match(/([a-z]+\-\w+)/i) ? pathEnd.match(/([a-z]+\-\w+)/i) : pathEnd; 
 let isBlog = folder === 'blog' ? true : false; 	 

 let fullPath = '../../'+ path;
  	 
  fetch(fullPath).then(res => res.text())
    .then(md => {
      let from = 0;
      let hashAt;	   
      for(let i=0; i < md.length; i++) {
        if (md[i] === '\n'&& md[i+1] !== '\n') {
 let raw = {"head":'', "text": ''};	

       if (i > hashAt && hashAt === from) {
	  let strHash = md.slice(from, i);
//		 console.log(strHash)
	  strHash = strHash.split('{')[0];
 	  strHash = strHash.toLowerCase();		
  	 let strToPath = strHash.replace(/[#]\s/g, '#');
	  strToPath = strToPath.trim();	
//		console.log(strToPath);
	  strToPath = strToPath.replace(/(')|([?])|([!])|([$])|([&])|([(])|([)])|([*])|([+])|([,])|([;])|([=])/g, '');		
	  strToPath = strToPath.replace(/(:)|(\s)|(@)/g, '-');		
          strToPath = strToPath.replace(/[-]+/g, '-');		
//		console.log(strToPath);
 let hashT = strHash.match(/#+/);	  		
	  rawHead = hashT[0]
          raw.head = isBlog ? routePaths(path) + strToPath : path + strToPath;	
//		 console.log(hashT);
//            if (head.length < hashT.length) {
	      head = hashT;
//	    }
	    
	}
	
	let rawText = md.slice(from, i);
rawText = rawText.replace(/(\[)|(\])|([(].+[)])|(<(“[^”]*”|'[^’]*’|[^'”>])*>)|(\n)|([{]\s?#+.+[}])/g, '');
		raw.text = rawText;
//		console.log(raw);
//	        raws.push(raw);
this.add(raw);		
        from = i + 1;		
	}
          if (md[i] === '#' && md[i-1] === '\n') {
 	  hashAt = i;		  
//		 console.log('#')
	   }    
      }
//	    console.log(raws.length)
//console.log(raws);	    
    })	 
 })

});
console.log(e.target.value);
console.log(idx.search(e.target.value));
console.log(idx.search('Welcome'))
}

function test() {
	console.log(routePaths());
 	let origins = Object.keys(client.origins);
let sites = [];	
  origins.forEach(site => {
    let format = site.slice(-4);
    let rawPath = site.slice(6);	  
    if (format.includes('.md') || format.includes('.mdx')) {
      sites.push(rawPath);
    }
  })	
//	console.log(sites);
 let raws = [];
 let head = '#';	
 sites.forEach(path => {
 let fullPath = '../../'+ path;
   fetch(fullPath).then(res => res.text())
    .then(md => {
      let from = 0;
      let hashAt;	    
      for(let i=0; i < md.length; i++) {
        if (md[i] === '\n') {
        if (i > hashAt && hashAt === from) {
	  let strHash = md.slice(from, i);
//		 console.log(strHash)
          let hashT = strHash.match(/#+/);
	  hashT = hashT[0]
//		 console.log(hashT);
            if (head.length < hashT.length) {
	      head = hashT;
	    }
	    
	}

        raws.push(md.slice(from, i));
        from = i + 1;		
	}
          if (md[i] === '#' && md[i-1] === '\n') {
 	  hashAt = i;		  
//		 console.log('#')
	   }    
      }
    })	 
 })
//console.log(raws)
 let docs = '../../blog/2019-05-28-hola.md';  	
//  fetch(docs).then(res => res.text())
//	.then(data => console.log(data))
//  let str = ReactDOMServer.renderToString(<Doc1/>);
//  const md = html2md(str, {emptyTags:['code', 'blockquote']});
/*
  let idx = lunr(function () {
  this.ref('name')
  this.field('text')
  this.metadataWhitelist = ['position'];
  let arrMd = md.split('\n');
  arrMd.forEach(data => {
	  let obj = {name: 'd', text: data}
	  this.add(obj);
  })
 });
	*/
//	  console.log(md);
//  let arrMd = md.split('\n');
//console.log(arrMd);
let jsn = md2json.parse('dd');
//	  console.log(jsn);
//  console.log(idx.search("Greetings"));  	  
var documents = [{
  "name": "Lunr",
  "text": "Like Solr, but much smaller, and not as bright."
}, {
  "name": "React",
  "text": "A JavaScript library for building user interfaces."
}, {
  "name": "Lodash",
  "text": "A modern JavaScript utility library delivering modularity, performance & extras."
}];
var idx = lunr(function () {
  this.ref('name')
  this.field('text')

  documents.forEach(function (doc) {
    this.add(doc)
  }, this)
})
console.log(idx.search("bright"));

  }
test();

    return <div>

		 <input type="search" onChange={handleSearch} />
		  </div>

}

export default SearchBar;
